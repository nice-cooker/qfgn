// **********************************************************************
//
// Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.7.0
//
// <auto-generated>
//
// Generated from file `QFGNServerClientProto.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __QFGNServerClientProto_h__
#define __QFGNServerClientProto_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 0
#       error Ice patch level mismatch!
#   endif
#endif

namespace QFGNServerClientProto
{

enum ESvrCmdID
{
    ESvrCmdIDRegister,
    ESvrCmdIDRegisterNO,
    ESvrCmdIDLogin,
    ESvrCmdIDModifyKey
};

enum ESvrCmdType
{
    ESvrCmdTypeRequest,
    ESvrCmdTypeResponse,
    ESvrCmdTypeNotify
};

typedef ::std::vector< ::Ice::Byte> ByteBuff;

struct TPackage
{
    ::std::string strUid;
    ::std::string strPassword;
    ::std::string strClientVer;
    ::QFGNServerClientProto::ESvrCmdID eCmdId;
    ::QFGNServerClientProto::ESvrCmdType eCmdType;
    ::QFGNServerClientProto::ByteBuff vecCmdData;
};

struct TGetRegisterNOReq
{
    ::std::string sUid;
    ::std::string sKey;
    ::std::string sExt1;

    bool operator==(const TGetRegisterNOReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TGetRegisterNOReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TGetRegisterNOReq& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TGetRegisterNOReq& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TGetRegisterNOReq& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TGetRegisterNOReq& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TGetRegisterNORsp
{
    ::Ice::Int iReturn;
    ::std::string sExt1;

    bool operator==(const TGetRegisterNORsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(iReturn != __rhs.iReturn)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TGetRegisterNORsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(iReturn < __rhs.iReturn)
        {
            return true;
        }
        else if(__rhs.iReturn < iReturn)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TGetRegisterNORsp& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TGetRegisterNORsp& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TGetRegisterNORsp& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TGetRegisterNORsp& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TRegisterReq
{
    ::std::string sUid;
    ::std::string sRegisterNO;
    ::std::string sKey;
    ::std::string sExt1;

    bool operator==(const TRegisterReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sRegisterNO != __rhs.sRegisterNO)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TRegisterReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sRegisterNO < __rhs.sRegisterNO)
        {
            return true;
        }
        else if(__rhs.sRegisterNO < sRegisterNO)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TRegisterReq& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TRegisterReq& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TRegisterReq& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TRegisterReq& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TRegisterRsp
{
    ::Ice::Int iReturn;
    ::std::string sUid;
    ::std::string sKey;
    ::std::string sExt1;

    bool operator==(const TRegisterRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(iReturn != __rhs.iReturn)
        {
            return false;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TRegisterRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(iReturn < __rhs.iReturn)
        {
            return true;
        }
        else if(__rhs.iReturn < iReturn)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TRegisterRsp& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TRegisterRsp& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TRegisterRsp& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TRegisterRsp& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TLoginReq
{
    ::std::string sUid;
    ::std::string sKey;
    ::std::string sExt1;

    bool operator==(const TLoginReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TLoginReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TLoginReq& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TLoginReq& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TLoginReq& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TLoginReq& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TLoginRsp
{
    ::Ice::Int iReturn;
    ::std::string sExt1;

    bool operator==(const TLoginRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(iReturn != __rhs.iReturn)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TLoginRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(iReturn < __rhs.iReturn)
        {
            return true;
        }
        else if(__rhs.iReturn < iReturn)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TLoginRsp& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TLoginRsp& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TLoginRsp& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TLoginRsp& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TChangeKeyReq
{
    ::std::string sUid;
    ::std::string sCheckCode;
    ::std::string sKey;
    ::std::string sKeySure;
    ::std::string sExt1;

    bool operator==(const TChangeKeyReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sCheckCode != __rhs.sCheckCode)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sKeySure != __rhs.sKeySure)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TChangeKeyReq& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sCheckCode < __rhs.sCheckCode)
        {
            return true;
        }
        else if(__rhs.sCheckCode < sCheckCode)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sKeySure < __rhs.sKeySure)
        {
            return true;
        }
        else if(__rhs.sKeySure < sKeySure)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TChangeKeyReq& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TChangeKeyReq& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TChangeKeyReq& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TChangeKeyReq& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct TChangeKeyRsp
{
    ::Ice::Int iReturn;
    ::std::string sUid;
    ::std::string sKey;
    ::std::string sExt1;

    bool operator==(const TChangeKeyRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(iReturn != __rhs.iReturn)
        {
            return false;
        }
        if(sUid != __rhs.sUid)
        {
            return false;
        }
        if(sKey != __rhs.sKey)
        {
            return false;
        }
        if(sExt1 != __rhs.sExt1)
        {
            return false;
        }
        return true;
    }

    bool operator<(const TChangeKeyRsp& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(iReturn < __rhs.iReturn)
        {
            return true;
        }
        else if(__rhs.iReturn < iReturn)
        {
            return false;
        }
        if(sUid < __rhs.sUid)
        {
            return true;
        }
        else if(__rhs.sUid < sUid)
        {
            return false;
        }
        if(sKey < __rhs.sKey)
        {
            return true;
        }
        else if(__rhs.sKey < sKey)
        {
            return false;
        }
        if(sExt1 < __rhs.sExt1)
        {
            return true;
        }
        else if(__rhs.sExt1 < sExt1)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const TChangeKeyRsp& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const TChangeKeyRsp& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const TChangeKeyRsp& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const TChangeKeyRsp& __rhs) const
    {
        return !operator<(__rhs);
    }
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::QFGNServerClientProto::ESvrCmdID>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::ESvrCmdType>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TPackage>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TPackage, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TPackage& v)
    {
        __os->write(v.strUid);
        __os->write(v.strPassword);
        __os->write(v.strClientVer);
        __os->write(v.eCmdId);
        __os->write(v.eCmdType);
        __os->write(v.vecCmdData);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TPackage, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TPackage& v)
    {
        __is->read(v.strUid);
        __is->read(v.strPassword);
        __is->read(v.strClientVer);
        __is->read(v.eCmdId);
        __is->read(v.eCmdType);
        __is->read(v.vecCmdData);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TGetRegisterNOReq>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TGetRegisterNOReq, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TGetRegisterNOReq& v)
    {
        __os->write(v.sUid);
        __os->write(v.sKey);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TGetRegisterNOReq, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TGetRegisterNOReq& v)
    {
        __is->read(v.sUid);
        __is->read(v.sKey);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TGetRegisterNORsp>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TGetRegisterNORsp, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TGetRegisterNORsp& v)
    {
        __os->write(v.iReturn);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TGetRegisterNORsp, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TGetRegisterNORsp& v)
    {
        __is->read(v.iReturn);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TRegisterReq>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TRegisterReq, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TRegisterReq& v)
    {
        __os->write(v.sUid);
        __os->write(v.sRegisterNO);
        __os->write(v.sKey);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TRegisterReq, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TRegisterReq& v)
    {
        __is->read(v.sUid);
        __is->read(v.sRegisterNO);
        __is->read(v.sKey);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TRegisterRsp>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TRegisterRsp, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TRegisterRsp& v)
    {
        __os->write(v.iReturn);
        __os->write(v.sUid);
        __os->write(v.sKey);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TRegisterRsp, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TRegisterRsp& v)
    {
        __is->read(v.iReturn);
        __is->read(v.sUid);
        __is->read(v.sKey);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TLoginReq>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TLoginReq, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TLoginReq& v)
    {
        __os->write(v.sUid);
        __os->write(v.sKey);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TLoginReq, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TLoginReq& v)
    {
        __is->read(v.sUid);
        __is->read(v.sKey);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TLoginRsp>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TLoginRsp, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TLoginRsp& v)
    {
        __os->write(v.iReturn);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TLoginRsp, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TLoginRsp& v)
    {
        __is->read(v.iReturn);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TChangeKeyReq>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TChangeKeyReq, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TChangeKeyReq& v)
    {
        __os->write(v.sUid);
        __os->write(v.sCheckCode);
        __os->write(v.sKey);
        __os->write(v.sKeySure);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TChangeKeyReq, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TChangeKeyReq& v)
    {
        __is->read(v.sUid);
        __is->read(v.sCheckCode);
        __is->read(v.sKey);
        __is->read(v.sKeySure);
        __is->read(v.sExt1);
    }
};

template<>
struct StreamableTraits< ::QFGNServerClientProto::TChangeKeyRsp>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::QFGNServerClientProto::TChangeKeyRsp, S>
{
    static void write(S* __os, const ::QFGNServerClientProto::TChangeKeyRsp& v)
    {
        __os->write(v.iReturn);
        __os->write(v.sUid);
        __os->write(v.sKey);
        __os->write(v.sExt1);
    }
};

template<class S>
struct StreamReader< ::QFGNServerClientProto::TChangeKeyRsp, S>
{
    static void read(S* __is, ::QFGNServerClientProto::TChangeKeyRsp& v)
    {
        __is->read(v.iReturn);
        __is->read(v.sUid);
        __is->read(v.sKey);
        __is->read(v.sExt1);
    }
};

}

#include <IceUtil/PopDisableWarnings.h>
#endif
